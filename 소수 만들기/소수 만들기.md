# 소수 만들기

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12977)  
프로그래머스 Lv. 1

## 문제 설명

주어진 숫자 중 3개의 수를 더했을 때 소수가 되는 경우의 개수를 구하려고 합니다.
숫자들이 들어있는 배열 nums가 매개변수로 주어질 때, nums에 있는 숫자들 중
서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return 하도록
solution 함수를 완성해주세요.

## 제한사항

nums에 들어있는 숫자의 개수는 3개 이상 50개 이하입니다.
nums의 각 원소는 1 이상 1,000 이하의 자연수이며, 중복된 숫자가 들어있지 않습니다.

## 생각 정리

기본적인 구성은 3개의 수를 더하는 모든 경우의 수에 대해, 소수인지 검사하는 방식이 될 것이다.

```pseudo code
for(i, j, k) //순서에 상관 없이 3개를 고르는 루프
{
    sum = nums[i] + nums[j] + nums[k];
    if(IsPrime(sum))
        answer++;
}
```

가장 우려되는 점은 소수의 검사 방식이다. 단순한 검사 방식으로는 모든 sum에 대해 2부터 √(sum)까지 모든 수로 나누어 보아야 할 것이다. 우선 단순한 방식으로 구현을 해본 뒤, 떠오르는 개선 방안을 적용해 보았다.

## 1차 구현

### 코드

```C#
using System;

class Solution
{
    private bool IsPrime(int value)
    {
        int range = (int)Math.Sqrt(value);
        for (int i = 2; i <= range; i++)
        {
            if (value % i == 0)
                return false;
        }
        return true;
    }

    public int solution(int[] nums)
    {
        int answer = 0;

        for (int i = 0; i < nums.Length; i++)
        {
            for (int j = i + 1; j < nums.Length; j++)
            {
                for (int k = j + 1; k < nums.Length; k++)
                {
                    if (IsPrime(nums[i] + nums[j] + nums[k]))
                        answer++;
                }
            }
        }

        return answer;
    }
}
```

### 결과

모든 테스트를 통과했다(...)  
타임아웃이 걸리는 테스트가 생길거라고 예상했는데 Lv. 1이기도 하고 알고리즘 작성 능력만 본 것 같다.

다시 생각해보면 nums의 원소는 기껏해야 1000으로 제한되어 있고 √(3000)은 54에 불과하니 최적화를 한다면 54까지의 소수표를 아예 입력해두고 소수에 대해서만 나머지 검사를 하는 것으로 충분할 것으로 생각된다.
