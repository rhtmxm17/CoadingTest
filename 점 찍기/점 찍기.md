# 점 찍기

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/140107)  
프로그래머스 Lv. 2

## 문제 설명

좌표평면을 좋아하는 진수는 x축과 y축이 직교하는 2차원 좌표평면에 점을 찍으면서 놀고 있습니다. 진수는 두 양의 정수 k, d가 주어질 때 다음과 같이 점을 찍으려 합니다.

* 원점(0, 0)으로부터 x축 방향으로 a\*k(a = 0, 1, 2, 3 ...), y축 방향으로 b\*k(b = 0, 1, 2, 3 ...)만큼 떨어진 위치에 점을 찍습니다.
* 원점과 거리가 d를 넘는 위치에는 점을 찍지 않습니다.

예를 들어, k가 2, d가 4인 경우에는 (0, 0), (0, 2), (0, 4), (2, 0), (2, 2), (4, 0) 위치에 점을 찍어 총 6개의 점을 찍습니다.

정수 k와 원점과의 거리를 나타내는 정수 d가 주어졌을 때, 점이 총 몇 개 찍히는지 return 하는 solution 함수를 완성하세요.

### 제한사항

* 1 ≤ k ≤ 1,000,000
* 1 ≤ d ≤ 1,000,000

## 생각 정리

복잡하게 적어는 놓았지만 결국 원점과의 거리가 d 이하인 점 (a\*k, b\*k)의 개수를 계산하는 함수를 만들라는 문제이다.

d 이하인 최대의 a(max)을 구하고, (0, 0) 부터 (max \* k, max \* k)까지의 모든 점의 원점과의 거리를 측정하는 것이 기본 구성이 될 것이다. 거리를 측정하는 과정에서 제곱을 하게 될 것이고, d<sup>2</sup>의 최대값은 1,000,000,000,000으로 int범위를 벗어났으니 제곱 수행 전에 long으로 캐스팅 해준다.

## 1차 구현

우선 문제 이해 확인차 이중 반복문으로 모든 점을 검사해보았다. 오버플로우가 발생하는 int * int 곱셈에서 long 자료형에 담을 때, 곱셈을 하기 전에 먼저 형 변환을 하는 것을 잊는 바람에 오류 찾기에 어려움을 겪은 일이 있었다. 컴파일 오류가 발생하지 않는 오류인 만큼 특히 주의하자.

### 1차 코드

```C#
public class Solution
{
    public long solution(int k, int d)
    {
        long answer = 0;
        long dPow = (long)d * (long)d;

        for (long ak = 0; ak <= d; ak += k)
        {
            for (long bk = 0; bk <= d; bk += k)
            {
                if ((ak * ak + bk * bk) <= dPow)
                    answer++;
            }
        }

        return answer;
    }
}
```

### 1차 결과

몇개의 테스트에서 시간 초과로 실패했지만, 논리적인 오류가 발생하지 않았음을 확인했다. O(n<sup>2</sup>)으로 인해 최대 1조를 넘는 반복문을, 그것도 long 연산을 수행한 결과이다.

## 2차 구현

1차 구현의 가장 큰 문제점은 한번에 하나의 점만 검사했기 때문에 O(n<sup>2</sup>)라는 것이다. 하나의 a 값에 대해 가능한 가장 큰 b값만 찾으면 자연히 그보다 작은 모든 b 값을 사용하는 점은 원점과의 거리가 d보다 짧을 것이다.

### 코드

```C#
using System;
public class Solution
{
    public long solution(int k, int d)
    {
        long answer = 0;
        long dPow = (long)d * (long)d;

        for (int a = 0; ; a++)
        {
            int x = k * a;  // x길이
            if(x > d)       // x길이가 이미 제한거리를 넘었을 경우
                break;

            long maxYPow = dPow - (long)x * x;
            int maxY = (int)Math.Sqrt(maxYPow); // 최대 y 길이
            int maxB = maxY / k; // 최대 b값
            answer += maxB + 1;  // b == 0일 경우를 포함해야 한다
        }

        return answer;
    }
}
```

### 결과

성공적으로 시간을 단축해 테스트를 통과할 수 있었다.
